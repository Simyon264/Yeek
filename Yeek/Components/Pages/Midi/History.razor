@page "/{Guid:guid}/history"
@using System.Globalization
@using System.Text.Encodings.Web
@using System.Web
@using Yeek.FileHosting.Model
@using Yeek.FileHosting.Repositories
@using Yeek.Security.Model
@using Yeek.Security.Repositories

@inject IHttpContextAccessor HttpContext

@if (_file == null || _thisRevisionUser == null)
{
    <PageTitle>Yeek - Not Found</PageTitle>
    <p class="error-text">File not found.</p>
    return;
}

<PageTitle>Yeek - History: @_file.MostRecentRevision.TrackName</PageTitle>

@if (_isOutOfRange)
{
    <p class="error-text">Requested range is... Out of range.</p>
    return;
}

<h4>@_file.MostRecentRevision.TrackName</h4>

<div class="midi-page-info">
    <p><strong>Author: </strong>@_file.MostRecentRevision.ArtistName</p>
    <p><strong>Album: </strong>@_file.MostRecentRevision.AlbumName</p>

    <p class="midi-page-description">
        @_file.MostRecentRevision.Description
    </p>
    <p class="midi-page-uploaded-by">
        Revision by: @_thisRevisionUser.DisplayName
    </p>

    <a class="report-button" href="/moderation/report/new?topic=midi-@HtmlEncoder.Default.Encode($"{_file.Id}-rev-{_file.MostRecentRevision.RevisionId}")" target="_blank">Report content</a>
</div>

<ul class="midi-history-revision-list">
    @foreach (var revision in _revisions)
    {
        <li>
            <a href="/@Guid/history?rev=@revision.RevisionId">@revision.UpdatedOn.ToString("F", CultureInfo.InvariantCulture)</a>
            @if (revision.RevisionId == _file.MostRecentRevision.RevisionId)
            {
                <small>You are here!</small>
            }
            <p class="midi-history-rev-author">By: @revision.UpdatedBy</p>
            <p class="midi-history-rev-summary">@revision.ChangeSummary</p>
        </li>
    }
</ul>

@code {
    [Parameter]
    public Guid Guid { get; set; }

    [Inject] private IFileRepository FileRepository { get; set; } = null!;
    [Inject] private IUserRepository UserRepository { get; set; } = null!;
    [Inject] private NavigationManager NavigationManager { get; set; } = null!;

    private UploadedFile? _file = null;
    private bool _isOutOfRange = false;
    private int _revisionNumber = 0;
    private List<SummarizedRevision> _revisions = [];
    private User? _thisRevisionUser;

    protected override async Task OnParametersSetAsync()
    {
        var fileIsReal = await FileRepository.FileExistsAsync(Guid);
        if (!fileIsReal)
        {
            HttpContext.HttpContext!.Response.StatusCode = 404;
            return;
        }

        var url = new Uri(NavigationManager.Uri);
        var dict = HttpUtility.ParseQueryString(url.Query);

        var tempRevNumber = dict.Get("rev");
        if (int.TryParse(tempRevNumber, out var result))
        {
            _revisionNumber = result;
        }

        try
        {
            _revisions = await FileRepository.GetRevisionsAsync(Guid);
            if (tempRevNumber == null)
            {
                var newestRevision = _revisions.OrderByDescending(x => x.RevisionId)
                    .FirstOrDefault();

                if (newestRevision != null)
                {
                    _revisionNumber = newestRevision.RevisionId;
                }
            }

            _file = await FileRepository.GetUploadedFileWithSpecificRevisionAsync(Guid, _revisionNumber);
            _thisRevisionUser = await UserRepository.GetUserAsync(_file.MostRecentRevision.UpdatedById);
            HttpContext.HttpContext!.Response.StatusCode = 200;
        }
        catch (ArgumentOutOfRangeException)
        {
            HttpContext.HttpContext!.Response.StatusCode = 400;
            _isOutOfRange = true;
        }
    }
}