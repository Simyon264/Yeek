@page "/"
@using System.Web
@using Yeek.FileHosting.Model
@using Yeek.FileHosting.Repositories

<PageTitle>Yeek - MIDI Sharing</PageTitle>

<OpenGraph>
    <meta property="og:title" content="Yeek - MIDI Sharing"/>
    <meta property="og:description" content="Hosting your MIDI files for all your Space Station needs."/>
    <meta property="og:type" content="website"/>
</OpenGraph>

<div class="search">
    <h4>Search</h4>
    <form id="mainsearch">
        <input value="@_query" name="search" type="text" placeholder="Type in an artist, album or track name..."/>
        <label for="sortby">Sort by:</label>
        <select name="sortby" id="sortby">
            @switch (_sortBy)
            {
                // There is a better way to do this. I don't care.
                case "relevance":
                    <option value="relevance" selected>Relevance</option>
                    <option value="top">Top Rated</option>
                    <option value="recent">Most Recent</option>
                    break;

                case "top":
                    <option value="relevance">Relevance</option>
                    <option value="top" selected>Top Rated</option>
                    <option value="recent">Most Recent</option>
                    break;

                default:
                case "recent":
                    <option value="relevance">Relevance</option>
                    <option value="top">Top Rated</option>
                    <option value="recent" selected>Most Recent</option>
                    break;
            }
        </select>
        <input type="submit" value="Search"/>
    </form>
</div>

@if (string.IsNullOrWhiteSpace(_query))
{
    <p>Serving <span>@_totalCount</span> MIDIs to Space Stations around the Galaxy.<br/> Type in a keyword to get started.</p>
}
else if (_totalCount == 0)
{
    <p>No results found :(</p>
    <small>Do you have a MIDI for this? Upload it!</small>
}
else
{
    <p>Found @_totalCount result(s).</p>
}
<div class="search-results">
    @foreach (var uploadedFile in _results)
    {
        <MidiCard File="uploadedFile"/>
    }
</div>

@if (_maxPages > 1)
{
    <nav class="pagination">
        <ul>
            @* Previous button *@
            <li class="@(_page == 0 ? "disabled" : "")">
                @{
                    var prevPage = Math.Max(0, _page - 1);
                    var prevQuery = BuildQuery(prevPage);
                }
                <a href="/?@prevQuery" class="page-link">Previous</a>
            </li>

            @foreach (var pageNum in GetVisiblePages(_page, _maxPages))
            {
                if (pageNum == -1)
                {
                    <li class="ellipsis">
                        <a href="javascript:void(0);" class="page-link" onclick="jumpToPage(@_maxPages)">…</a>
                    </li>
                }
                else
                {
                    var isCurrent = pageNum == _page;
                    var pageQuery = BuildQuery(pageNum);
                    <li class="@(isCurrent ? "current" : "")">
                        <a href="/?@pageQuery" class="page-link">@(@pageNum + 1)</a>
                    </li>
                }
            }

            @* Next button *@
            <li class="@(_page >= _maxPages - 1 ? "disabled" : "")">
                @{
                    var nextPage = Math.Min(_maxPages - 1, _page + 1);
                    var nextQuery = BuildQuery(nextPage);
                }
                <a href="/?@nextQuery" class="page-link">Next</a>
            </li>
        </ul>
    </nav>
}

<script>
function jumpToPage(maxPages) {
    let page = prompt(`Enter a page number between 1 and ${maxPages}:`);
    if (page === null) return; // user canceled

    page = parseInt(page);
    if (isNaN(page) || page < 1 || page > maxPages) {
        alert("Invalid page number.");
        return;
    }

    const params = new URLSearchParams(window.location.search);
    params.set("page", page - 1); // convert to 0-indexed
    window.location.search = params.toString();
}
</script>

@code
{
    private List<UploadedFile> _results = [];
    private int _page = 0;
    private int _maxPages = 0;
    private string? _query;

    private int _totalCount;
    private string _sortBy = "recent";

    [Inject]
    private NavigationManager NavigationManager { get; set; } = null!;

    [Inject]
    private IFileRepository FileRepository { get; set; } = null!;

    protected override async Task OnParametersSetAsync()
    {
        var url = new Uri(NavigationManager.Uri);
        var dict = HttpUtility.ParseQueryString(url.Query);

        _query = dict.Get("search");
        var page = dict.Get("page");
        int.TryParse(page, out _page);
        _sortBy = dict.Get("sortby") ?? _sortBy;

        var sortByParsed = Enum.Parse<SearchMode>(_sortBy, true);
        _query ??= string.Empty;

        if (_page < 0)
            _page = 0;

        var searchResult = await FileRepository.SearchAsync(_query, sortByParsed, _page, 4*4); // max pages: 4 per row, 6 rows
        _totalCount = searchResult.allCount;
        _maxPages = searchResult.pageCount;
        _results = searchResult.result;
    }

    private string BuildQuery(int page)
    {
        var query = HttpUtility.ParseQueryString(string.Empty);
        if (!string.IsNullOrWhiteSpace(_query)) query["search"] = _query;
        query["sortby"] = _sortBy;
        query["page"] = page.ToString();
        return query.ToString();
    }

    private IEnumerable<int> GetVisiblePages(int current, int total)
    {
        const int maxVisible = 7; // max number of page buttons to show
        const int edgeCount = 2; // always show first and last 2 pages

        if (total <= maxVisible)
        {
            return Enumerable.Range(0, total);
        }

        var pages = new List<int>();

        // always show first edgeCount pages
        for (var i = 0; i < edgeCount; i++)
            pages.Add(i);

        // left ellipsis
        if (current - 1 > edgeCount)
            pages.Add(-1);

        // middle pages
        var start = Math.Max(edgeCount, current - 1);
        var end = Math.Min(total - edgeCount - 1, current + 1);

        for (var i = start; i <= end; i++)
            pages.Add(i);

        // right ellipsis
        if (current + 2 < total - edgeCount)
            pages.Add(-1);

        // last edgeCount pages
        for (var i = total - edgeCount; i < total; i++)
            pages.Add(i);

        // remove duplicates
        return pages.Distinct();
    }
}
